/**
 * Audit View - JavaScript functions for audit details page
 * Application MVC pattern - View component
 */

// Add these triple-slash directives at the top of the file to ignore specific TypeScript checks
// @ts-nocheck

/**
 * Affiche une notification toast
 * @param {string} message - Le message à afficher
 * @param {string} type - Le type de notification (info, success, warning, error)
 * @param {boolean} isPersistent - Si la notification doit rester affichée ou disparaître automatiquement
 * @returns {Object|null} - L'objet toast si disponible, sinon null
 */
window.showToast = function (message, type = "info", isPersistent = false) {
  try {
    // Créer un conteneur pour les toasts s'il n'existe pas
    let toastContainer = document.getElementById("toast-container");
    if (!toastContainer) {
      toastContainer = document.createElement("div");
      toastContainer.id = "toast-container";
      toastContainer.className =
        "toast-container position-fixed bottom-0 end-0 p-3";
      document.body.appendChild(toastContainer);
    }

    // Générer un ID unique pour ce toast
    const toastId = "toast-" + Date.now();

    // Créer l'élément toast
    const toastElement = document.createElement("div");
    toastElement.id = toastId;
    toastElement.className = `toast align-items-center text-white bg-${
      type === "error" ? "danger" : type
    }`;
    toastElement.setAttribute("role", "alert");
    toastElement.setAttribute("aria-live", "assertive");
    toastElement.setAttribute("aria-atomic", "true");

    // Tous les toasts se ferment automatiquement après 2 secondes (2000ms)
    toastElement.setAttribute("data-bs-delay", "2000");
    toastElement.setAttribute("data-bs-autohide", "true");

    // Contenu du toast
    toastElement.innerHTML = `
      <div class="d-flex">
        <div class="toast-body">
          ${message}
        </div>
        <button type="button" class="btn-close btn-close-white me-2 m-auto" 
                data-bs-dismiss="toast" aria-label="Fermer"></button>
      </div>
    `;

    // Ajouter le toast au conteneur
    toastContainer.appendChild(toastElement);

    // Initialiser le toast avec Bootstrap
    // Vérifier que Bootstrap est disponible
    if (typeof bootstrap !== "undefined" && bootstrap.Toast) {
      const toastBootstrap = new bootstrap.Toast(toastElement);
      toastBootstrap.show();
      return toastBootstrap;
    } else {
      // Fallback manuel si Bootstrap n'est pas disponible
      console.warn("Bootstrap non disponible, affichage manuel du toast");
      toastElement.classList.add("show");
      // Fermer après 2 secondes
      setTimeout(() => {
        toastElement.classList.remove("show");
        setTimeout(() => {
          if (toastElement.parentNode) {
            toastElement.parentNode.removeChild(toastElement);
          }
        }, 300);
      }, 2000);
      
      return {
        hide: () => {
          toastElement.classList.remove("show");
          if (toastElement.parentNode) {
            toastElement.parentNode.removeChild(toastElement);
          }
        },
      };
    }
  } catch (error) {
    console.error("Erreur lors de l'affichage du toast:", error);
    // En cas d'erreur, utiliser alert comme fallback
    alert(message);
    return null;
  }
};

/**
 * @typedef {Object} Bootstrap
 * @property {Object} Modal
 * @property {function} Modal.getInstance
 */

/**
 * @typedef {Object} WindowWithBootstrap
 * @property {Bootstrap} bootstrap
 */

/**
 * @typedef {Object} FileReaderEventTarget
 * @property {string|ArrayBuffer} result
 */

/**
 * @typedef {Object} FileReaderEvent
 * @property {FileReaderEventTarget} target
 */

// Variables globales
const videoStreams = {};

// Pour Ã©viter les erreurs avec bootstrap
const bootstrap = window.bootstrap || {};

/**
 * Module AuditDB - Gestion du stockage hors ligne pour les audits
 */
const AuditDB = (function () {
  // Base de donnÃ©es IndexedDB
  let db = null;
  const DB_NAME = "audit_offline_db";
  const DB_VERSION = 1;

  // Structure des stores
  const STORES = {
    PENDING_EVALUATIONS: "pending_evaluations",
    PENDING_DOCUMENTS: "pending_documents",
  };

  // Initialisation de la base de donnÃ©es
  function initDB() {
    return new Promise((resolve, reject) => {
      if (db) return resolve(db);

      const request = indexedDB.open(DB_NAME, DB_VERSION);

      request.onerror = (event) => {
        console.error("Erreur d'ouverture de la base de donnÃ©es:", event);
        reject(new Error("Impossible d'ouvrir la base de donnÃ©es IndexedDB"));
      };

      request.onsuccess = (event) => {
        db = event.target.result;
        console.log("Base de donnÃ©es IndexedDB ouverte avec succÃ¨s");
        resolve(db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;

        // CrÃ©er le store pour les Ã©valuations en attente
        if (!db.objectStoreNames.contains(STORES.PENDING_EVALUATIONS)) {
          db.createObjectStore(STORES.PENDING_EVALUATIONS, {
            keyPath: "id",
            autoIncrement: true,
          });
          console.log("Store crÃ©Ã© pour les Ã©valuations en attente");
        }

        // CrÃ©er le store pour les documents en attente
        if (!db.objectStoreNames.contains(STORES.PENDING_DOCUMENTS)) {
          db.createObjectStore(STORES.PENDING_DOCUMENTS, {
            keyPath: "id",
            autoIncrement: true,
          });
          console.log("Store crÃ©Ã© pour les documents en attente");
        }
      };
    });
  }

  // Ajout d'une Ã©valuation Ã  synchroniser
  async function savePendingEvaluation(data) {
    await initDB();

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(
        [STORES.PENDING_EVALUATIONS],
        "readwrite"
      );
      const store = transaction.objectStore(STORES.PENDING_EVALUATIONS);

      const item = {
        ...data,
        timestamp: new Date().getTime(),
        status: "pending",
      };

      const request = store.add(item);

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onerror = (event) => {
        reject(new Error("Erreur lors de l'enregistrement de l'Ã©valuation"));
      };
    });
  }

  // Ajout d'un document Ã  synchroniser
  async function savePendingDocument(data) {
    await initDB();

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(
        [STORES.PENDING_DOCUMENTS],
        "readwrite"
      );
      const store = transaction.objectStore(STORES.PENDING_DOCUMENTS);

      const item = {
        ...data,
        timestamp: new Date().getTime(),
        status: "pending",
      };

      const request = store.add(item);

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onerror = (event) => {
        reject(new Error("Erreur lors de l'enregistrement du document"));
      };
    });
  }

  // RÃ©cupÃ©rer toutes les Ã©valuations en attente
  async function getPendingEvaluations() {
    await initDB();

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(
        [STORES.PENDING_EVALUATIONS],
        "readonly"
      );
      const store = transaction.objectStore(STORES.PENDING_EVALUATIONS);
      const request = store.getAll();

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onerror = (event) => {
        reject(
          new Error("Erreur lors de la rÃ©cupÃ©ration des Ã©valuations en attente")
        );
      };
    });
  }

  // RÃ©cupÃ©rer tous les documents en attente
  async function getPendingDocuments() {
    await initDB();

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(
        [STORES.PENDING_DOCUMENTS],
        "readonly"
      );
      const store = transaction.objectStore(STORES.PENDING_DOCUMENTS);
      const request = store.getAll();

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onerror = (event) => {
        reject(
          new Error("Erreur lors de la rÃ©cupÃ©ration des documents en attente")
        );
      };
    });
  }

  // Marquer une Ã©valuation comme synchronisÃ©e
  async function markEvaluationSynced(id) {
    await initDB();

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(
        [STORES.PENDING_EVALUATIONS],
        "readwrite"
      );
      const store = transaction.objectStore(STORES.PENDING_EVALUATIONS);
      const request = store.delete(id);

      request.onsuccess = () => {
        resolve(true);
      };

      request.onerror = () => {
        reject(new Error("Erreur lors de la mise Ã jour de l'Ã©valuation"));
      };
    });
  }

  // Marquer un document comme synchronisÃ©
  async function markDocumentSynced(id) {
    await initDB();

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(
        [STORES.PENDING_DOCUMENTS],
        "readwrite"
      );
      const store = transaction.objectStore(STORES.PENDING_DOCUMENTS);
      const request = store.delete(id);

      request.onsuccess = () => {
        resolve(true);
      };

      request.onerror = () => {
        reject(new Error("Erreur lors de la mise Ã jour du document"));
      };
    });
  }

  // Synchroniser les donnÃ©es en attente
  async function syncPendingData() {
    const results = {
      evaluations: { success: 0, failed: 0 },
      documents: { success: 0, failed: 0 },
    };

    try {
      // Synchroniser les Ã©valuations
      const pendingEvaluations = await getPendingEvaluations();
      console.log(
        `Synchronisation de ${pendingEvaluations.length} Ã©valuations en attente`
      );

      // Utiliser la fonction syncSingleEvaluation amÃ©liorÃ©e pour chaque Ã©valuation
      for (const evaluation of pendingEvaluations) {
        try {
          // Utiliser la fonction avancÃ©e de synchronisation d'Ã©valuation individuelle
          const success = await window.syncSingleEvaluation(evaluation);

          if (success) {
            results.evaluations.success++;
            console.log(
              `âœ… Ã‰valuation ID:${evaluation.id} synchronisÃ©e avec succÃ¨s`
            );
          } else {
            results.evaluations.failed++;
            console.error(
              `âŒ Ã‰chec de synchronisation de l'Ã©valuation ID:${evaluation.id}`
            );
          }
        } catch (error) {
          results.evaluations.failed++;
          console.error(
            "Exception lors de la synchronisation de l'Ã©valuation:",
            error
          );
        }
      }

      // Synchroniser les documents
      const pendingDocuments = await getPendingDocuments();
      console.log(
        `Synchronisation de ${pendingDocuments.length} documents en attente`
      );

      for (const document of pendingDocuments) {
        try {
          // Envoyer les donnÃ©es au serveur
          const response = await fetch(
            "index.php?action=audits&method=ajouterDocument",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-Requested-With": "XMLHttpRequest",
              },
              body: JSON.stringify({
                audit_id: document.audit_id,
                point_vigilance_id: document.point_vigilance_id,
                image_base64: document.image_base64,
              }),
            }
          );

          if (response.ok) {
            // Marquer comme synchronisÃ©
            await markDocumentSynced(document.id);
            results.documents.success++;
          } else {
            results.documents.failed++;
            console.error(
              "Erreur lors de la synchronisation de la photo:",
              await response.text()
            );
          }
        } catch (error) {
          results.documents.failed++;
          console.error(
            "Exception lors de la synchronisation du document:",
            error
          );
        }
      }

      console.log("Synchronisation terminÃ©e:", results);
      return results;
    } catch (error) {
      console.error("Erreur lors de la synchronisation:", error);
      throw error;
    }
  }

  // API publique
  return {
    initDB,
    savePendingEvaluation,
    savePendingDocument,
    getPendingEvaluations,
    getPendingDocuments,
    syncPendingData,
  };
})();

// Exposer le module AuditDB Ã  window pour une accessibilitÃ© globale
window.AuditDB = AuditDB;

/**
 * Initialisation au chargement du document
 */
document.addEventListener("DOMContentLoaded", function () {
  // Ajouter un style pour les champs dÃ©sactivÃ©s
  const style = document.createElement("style");
  style.innerHTML = `
    .disabled-field {
      background-color: #e9ecef !important;
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    /* Style pour formulaires non modifiables (audit terminÃ©) */
    form[disabled] {
      opacity: 0.8;
      pointer-events: none;
    }
    form[disabled] input, 
    form[disabled] textarea, 
    form[disabled] select, 
    form[disabled] button {
      pointer-events: none;
      background-color: #e9ecef;
      opacity: 0.7;
    }
  `;
  document.head.appendChild(style);

  // VÃ©rifier si l'audit est terminÃ©
  const badgeElement = document.querySelector(".badge.bg-success");
  const isAuditTermine =
    badgeElement !== null &&
    badgeElement.textContent &&
    badgeElement.textContent.trim() === "TerminÃ©";

  // GÃ©rer la soumission du formulaire d'Ã©valuation
  initEvaluationForms(isAuditTermine);

  // GÃ©rer la soumission des formulaires de documents
  initDocumentForms(isAuditTermine);

  // Initialiser les webcams pour chaque point de vigilance
  const pointsIds = document.querySelectorAll("[data-point-id]");
  pointsIds.forEach((element) => {
    const pointId = element.getAttribute("data-point-id");
    if (pointId) {
      initWebcam(parseInt(pointId));
    }
  });

  // Remplacer tous les aria-hidden par inert pour Ã©viter les problÃ¨mes d'accessibilitÃ©
  initModalAccessibility();

  // Fonction pour vÃ©rifier la connexion internet
  function isOnline() {
    return navigator.onLine;
  }

  // Fonction pour Ã©couter les changements de statut de connexion
  function setupConnectivityListeners() {
    console.log("Configuration des Ã©couteurs de connectivitÃ©");

    // VÃ©rifier si nous sommes en ligne au chargement
    if (!navigator.onLine) {
      console.log("DÃ©marrage en mode hors ligne");
      document.body.classList.add("offline-mode");
    }

    // Ã‰couteurs pour les Ã©vÃ©nements online/offline
    window.addEventListener("online", function () {
      console.log("ðŸŒ CONNEXION INTERNET RÃ‰TABLIE");
      document.body.classList.remove("offline-mode");

      // Notification Ã  l'utilisateur
      showToast(
        "Connexion internet rÃ©tablie. Synchronisation en cours...",
        "info",
        false
      );

      // DÃ©lai avant synchronisation
      setTimeout(() => {
        console.log("â±ï¸ DÃ©lai Ã©coulÃ©, dÃ©but de la synchronisation");

        forceSyncData()
          .then((result) => {
            if (!result.hasData) {
              showToast("Aucune donnÃ©e Ã  synchroniser", "info", false);
              return;
            }

            const total =
              result.results.evaluations.success +
              result.results.documents.success;
            const failed =
              result.results.evaluations.failed +
              result.results.documents.failed;

            if (total > 0) {
              showToast(
                `Synchronisation rÃ©ussie: ${total} Ã©lÃ©ment(s) synchronisÃ©(s)`,
                "success",
                true
              );

              // Recharger la page
              setTimeout(() => {
                const currentUrl = new URL(window.location.href);
                const auditId = currentUrl.searchParams.get("id");

                console.log("ðŸ"„ Rechargement de la page...");
                if (auditId) {
                  window.location.href = `index.php?action=audits&method=view&id=${auditId}&nocache=${Date.now()}`;
                } else {
                  window.location.href = `index.php?action=audits&nocache=${Date.now()}`;
                }
              }, 2000);
            } else if (failed > 0) {
              showToast(
                `Ã‰chec de la synchronisation: ${failed} Ã©lÃ©ment(s) non synchronisÃ©(s)`,
                "error",
                true
              );
            }
          })
          .catch((error) => {
            console.error("âŒ Erreur lors de la synchronisation:", error);
            showToast(
              "Erreur lors de la synchronisation: " +
                (error.message || "Erreur inconnue"),
              "error",
              true
            );
          });
      }, 2000); // Attendre 2 secondes avant de synchroniser
    });

    window.addEventListener("offline", function () {
      console.log("La connexion internet a Ã©tÃ© perdue");
      document.body.classList.add("offline-mode");

      showToast(
        "Mode hors ligne activÃ©. Vos modifications seront enregistrÃ©es localement.",
        "warning",
        true
      );
    });

    console.log("Ã‰couteurs de connectivitÃ© configurÃ©s");
  }

  // Initialiser les Ã©couteurs d'Ã©vÃ©nements de connectivitÃ© une fois le DOM chargÃ©
  setupConnectivityListeners();
});

/**
 * Initialise les formulaires d'Ã©valuation
 * GÃ¨re l'activation/dÃ©sactivation des champs en fonction de l'Ã©tat de la case "AuditÃ©"
 */
function initEvaluationForms(isAuditTermine) {
  const forms = document.querySelectorAll(".evaluation-form");
  console.log("Initialisation de", forms.length, "formulaires d'Ã©valuation");

  forms.forEach((form) => {
    // 1. RÃ©cupÃ©rer la case Ã  cocher "AuditÃ©" (non_audite)
    const nonAuditeCheckbox = form.querySelector('[name="non_audite"]');

    if (!nonAuditeCheckbox) {
      console.error("Case Ã  cocher 'AuditÃ©' non trouvÃ©e dans le formulaire");
      return;
    }

    // 2. Fonction pour mettre Ã  jour l'Ã©tat des champs en fonction de l'Ã©tat de la case "AuditÃ©"
    function updateFieldsState() {
      // RÃ©cupÃ©rer l'Ã©tat actuel de la case Ã  cocher
      const isNonAudite = nonAuditeCheckbox.checked;
      console.log(
        `Ã‰tat de la case 'AuditÃ©': ${isNonAudite ? "CochÃ©" : "Non cochÃ©"}`
      );

      // RÃ©cupÃ©rer tous les champs du formulaire
      const allInputs = form.querySelectorAll(
        'input:not([name="audit_id"]):not([name="point_vigilance_id"]):not([name="non_audite"]):not([name="mesure_reglementaire"])'
      );
      const allSelects = form.querySelectorAll("select");
      const allTextareas = form.querySelectorAll(
        'textarea:not([name="justification"])'
      );

      // RÃ©cupÃ©rer explicitement le champ de commentaire (qui doit rester actif)
      const justificationTextarea = form.querySelector(
        '[name="justification"]'
      );

      // DÃ‰SACTIVER tous les champs si "AuditÃ©" est dÃ©cochÃ©, SAUF "Mesure rÃ©glementaire" et "Commentaire"
      [...allInputs, ...allSelects, ...allTextareas].forEach((field) => {
        field.disabled = !isNonAudite || isAuditTermine;

        if (!isNonAudite || isAuditTermine) {
          field.classList.add("disabled-field");
        } else {
          field.classList.remove("disabled-field");
        }
      });

      // GÃ©rer sÃ©parÃ©ment les boutons radio
      const radioButtons = form.querySelectorAll('input[type="radio"]');
      radioButtons.forEach((radio) => {
        radio.disabled = !isNonAudite || isAuditTermine;

        // Appliquer des styles spÃ©cifiques pour l'Ã©lÃ©ment parent (libellÃ© du radio)
        const parentLabel = radio.closest("label") || radio.parentElement;
        if (parentLabel) {
          if (!isNonAudite || isAuditTermine) {
            parentLabel.classList.add("text-muted");
          } else {
            parentLabel.classList.remove("text-muted");
          }
        }
      });

      // S'assurer que le champ de commentaire reste toujours actif
      if (justificationTextarea) {
        justificationTextarea.disabled = isAuditTermine;
        if (isAuditTermine) {
          justificationTextarea.classList.add("disabled-field");
        } else {
          justificationTextarea.classList.remove("disabled-field");
        }
      }
    }

    // 3. Appliquer l'Ã©tat initial
    updateFieldsState();

    // 4. Ajouter un Ã©couteur pour dÃ©tecter les changements de la case Ã  cocher
    nonAuditeCheckbox.addEventListener("change", updateFieldsState);

    // 5. GÃ©rer la soumission du formulaire
    form.addEventListener("submit", function (e) {
      e.preventDefault();

      // Ne pas traiter si l'audit est terminÃ©
      if (isAuditTermine) {
        console.log("Formulaire non soumis : audit terminÃ©");
        return;
      }

      // RÃ©cupÃ©rer les donnÃ©es du formulaire
      const formData = new FormData(form);
      const auditId = formData.get("audit_id");
      const pointId = formData.get("point_vigilance_id");

      console.log(
        "Soumission du formulaire pour le point " +
          pointId +
          " de l'audit " +
          auditId
      );

      // VÃ©rifier si nous sommes en ligne
      if (!navigator.onLine) {
        console.log("Mode hors ligne dÃ©tectÃ©, enregistrement local...");
        // Stocker en local en attendant une connexion
        try {
          // Convertir FormData en objet JavaScript standard
          let evalData = {};
          for (let [key, value] of formData.entries()) {
            evalData[key] = value;
          }

          // Ajouter un timestamp et statut
          evalData.timestamp = new Date().getTime();
          evalData.status = "pending";

          console.log("DonnÃ©es converties pour stockage local:", evalData);

          // Assurons-nous que le module AuditDB est disponible et initialisÃ©
          if (typeof window.AuditDB === "undefined" || !window.AuditDB) {
            console.error("AuditDB non disponible. Tentative de chargement...");
            // Essayer de charger le script (fonction dÃ©finie plus bas)
            loadScriptDynamically("/Audit/public/assets/js/auditdb.js")
              .then(() => {
                console.log("Script auditdb.js chargÃ© avec succÃ¨s");
                if (!window.AuditDB) {
                  throw new Error(
                    "AuditDB toujours non disponible aprÃ¨s chargement"
                  );
                }
                return storeEvaluationOffline(evalData);
              })
              .then((id) => {
                console.log("Ã‰valuation stockÃ©e avec ID:", id);
                showToast(
                  "Ã‰valuation enregistrÃ©e localement. Sera synchronisÃ©e quand vous serez en ligne.",
                  "success",
                  true
                );
              })
              .catch((error) => {
                console.error("Erreur aprÃ¨s tentative de chargement:", error);
                showToast(
                  "Erreur lors de l'enregistrement local: " + error.message,
                  "error"
                );
              });
          } else {
            // AuditDB est disponible, utilisons-le directement
            storeEvaluationOffline(evalData)
              .then((id) => {
                console.log("Ã‰valuation stockÃ©e avec ID:", id);
                showToast(
                  "Ã‰valuation enregistrÃ©e localement. Sera synchronisÃ©e quand vous serez en ligne.",
                  "success",
                  true
                );
              })
              .catch((error) => {
                console.error("Erreur lors de l'enregistrement local:", error);
                showToast(
                  "Erreur lors de l'enregistrement local: " + error.message,
                  "error"
                );
              });
          }
        } catch (error) {
          console.error("Erreur lors de l'enregistrement local:", error);
          showToast(
            "Erreur lors de l'enregistrement local: " + error.message,
            "error"
          );
        }
        return;
      }

      // Envoyer les donnÃ©es au serveur
      fetch("index.php?action=audits&method=evaluerPoint", {
        method: "POST",
        headers: {
          "X-Requested-With": "XMLHttpRequest",
        },
        body: formData,
      })
        .then((response) => {
          if (!response.ok) {
            throw new Error("Erreur rÃ©seau: " + response.status);
          }
          return response.json();
        })
        .then((data) => {
          if (data.success) {
            showToast("Point de vigilance Ã©valuÃ© avec succÃ¨s", "success");
            console.log("SuccÃ¨s:", data);

            // Ajouter un paramÃ¨tre t pour Ã©viter la mise en cache
            setTimeout(() => {
              window.location.href =
                window.location.href.split("?")[0] +
                `?action=audits&method=view&id=${auditId}&t=${Date.now()}`;
            }, 500);
          } else {
            showToast(
              "Erreur lors de l'Ã©valuation: " +
                (data.message || "Erreur inconnue"),
              "error"
            );
            console.error("Erreur:", data);
          }
        })
        .catch((error) => {
          console.error("Erreur lors de l'envoi du formulaire:", error);
          showToast(
            "Erreur lors de l'envoi du formulaire: " + error.message,
            "error"
          );
        });
    });
  });
}

/**
 * Initialise les formulaires d'ajout de document
 */
function initDocumentForms(isAuditTermine) {
  const documentForms = document.querySelectorAll(".document-form");

  // Corriger les problÃ¨mes d'attributs aria-hidden sur les modals
  document.querySelectorAll(".modal").forEach((modal) => {
    // Remplacer aria-hidden par inert quand la modal est cachÃ©e
    if (modal.getAttribute("aria-hidden") === "true") {
      modal.removeAttribute("aria-hidden");
      modal.setAttribute("inert", "");
    }

    // S'assurer que la modal utilise inert au lieu de aria-hidden
    modal.addEventListener("hide.bs.modal", function () {
      // Utiliser un dÃ©lai pour permettre Ã Bootstrap de terminer sa fermeture
      setTimeout(() => {
        if (this.getAttribute("aria-hidden") === "true") {
          this.removeAttribute("aria-hidden");
          this.setAttribute("inert", "");
        }
      }, 50);
    });

    // Retirer inert lors de l'affichage
    modal.addEventListener("show.bs.modal", function () {
      if (this.hasAttribute("inert")) {
        this.removeAttribute("inert");
      }
    });
  });

  documentForms.forEach((form) => {
    form.addEventListener("submit", function (e) {
      e.preventDefault();
      console.log("Soumission du formulaire de document");

      // VÃ©rifier si les champs requis sont prÃ©sents
      const auditIdField = this.querySelector('input[name="audit_id"]');
      const pointVigilanceIdField = this.querySelector(
        'input[name="point_vigilance_id"]'
      );

      if (
        !auditIdField ||
        !pointVigilanceIdField ||
        !auditIdField.value ||
        !pointVigilanceIdField.value
      ) {
        alert(
          "Erreur: ParamÃ¨tres manquants (audit_id, point_vigilance_id). Veuillez rÃ©essayer."
        );
        return;
      }

      // CrÃ©er un nouveau FormData pour plus de contrÃ´le
      const formData = new FormData();

      // Ajouter explicitement les identifiants
      formData.append("audit_id", auditIdField.value);
      formData.append("point_vigilance_id", pointVigilanceIdField.value);
      formData.append("type", "document");

      // Ajouter le fichier
      const fileInput = this.querySelector('input[type="file"]');
      if (fileInput && fileInput.files && fileInput.files[0]) {
        formData.append("document", fileInput.files[0]);
        console.log("Fichier ajoutÃ©:", fileInput.files[0].name);
      } else {
        alert("Veuillez sÃ©lectionner un fichier Ã tÃ©lÃ©charger");
        return;
      }

      const submitBtn = this.querySelector('button[type="submit"]');
      const originalText = submitBtn.innerHTML;
      submitBtn.innerHTML =
        '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> TÃ©lÃ©chargement...';
      submitBtn.disabled = true;

      fetch("index.php?action=audits&method=ajouterDocument", {
        method: "POST",
        body: formData,
        headers: {
          "X-Requested-With": "XMLHttpRequest",
        },
      })
        .then((response) => {
          console.log("Status:", response.status);
          console.log("Headers:", [...response.headers.entries()]);

          if (!response.ok) {
            throw new Error("Erreur rÃ©seau: " + response.status);
          }

          // VÃ©rifier le type de contenu retournÃ©
          const contentType = response.headers.get("content-type");
          if (contentType && contentType.includes("text/html")) {
            // Le serveur a renvoyÃ© du HTML au lieu de JSON
            return response.text().then((html) => {
              console.error(
                "Le serveur a renvoyÃ© du HTML au lieu de JSON:",
                html.substring(0, 500)
              );
              throw new Error(
                "RÃ©ponse invalide du serveur (HTML au lieu de JSON)"
              );
            });
          }

          return response.text().then((text) => {
            console.log("Texte de la rÃ©ponse:", text);

            if (!text) {
              throw new Error("RÃ©ponse vide");
            }

            try {
              return JSON.parse(text);
            } catch (e) {
              console.error("Texte non JSON reÃ§u:", text.substring(0, 500));
              throw new Error("La rÃ©ponse n'est pas au format JSON");
            }
          });
        })
        .then((data) => {
          if (data.success) {
            console.log("Document ajoutÃ© avec succÃ¨s");

            // Fermer la modal de maniÃ¨re sÃ©curisÃ©e
            const modalId =
              "documentModal-" + formData.get("point_vigilance_id");
            const modal = document.getElementById(modalId);

            if (modal) {
              // Utiliser notre fonction closeModal pour une fermeture cohÃ©rente
              closeModal(modal);
            }

            // RafraÃ®chir la page avec un paramÃ¨tre pour Ã©viter le cache
            setTimeout(() => {
              window.location.href =
                window.location.href.split("?")[0] +
                `?action=audits&method=view&id=${
                  auditIdField.value
                }&nocache=${Date.now()}`;
            }, 300);
          } else {
            // Afficher un message d'erreur
            alert(
              data.message || "Une erreur est survenue lors du tÃ©lÃ©chargement"
            );
          }
        })
        .catch((error) => {
          console.error("Erreur lors du tÃ©lÃ©chargement:", error);
          alert(
            "Une erreur est survenue lors de la communication avec le serveur: " +
              error.message
          );
        })
        .finally(() => {
          // Restaurer le bouton
          submitBtn.innerHTML = originalText;
          submitBtn.disabled = false;
        });
    });
  });
}

/**
 * Initialise l'accessibilitÃ© des modales
 */
function initModalAccessibility() {
  document.querySelectorAll(".modal").forEach((modal) => {
    modal.addEventListener("hide.bs.modal", function () {
      // Supprimer aria-hidden qui cause des problÃ¨mes d'accessibilitÃ©
      setTimeout(() => {
        if (this.getAttribute("aria-hidden") === "true") {
          this.removeAttribute("aria-hidden");
          // Utiliser inert Ã  la place (plus moderne et sans conflit de focus)
          this.setAttribute("inert", "");
        }
      }, 0);
    });

    modal.addEventListener("show.bs.modal", function () {
      // Supprimer inert lors de l'affichage
      if (this.hasAttribute("inert")) {
        this.removeAttribute("inert");
      }
    });
  });
}

/**
 * Afficher la modal pour voir une photo
 * @param {string} photoUrl - L'URL de la photo Ã  afficher
 * @param {string} photoName - Le nom de la photo
 */
function showPhotoModal(photoUrl, photoName) {
  try {
    // Mettre Ã  jour la source de l'image
    const modalPhoto = document.getElementById("modal-photo");
    const modalLabel = document.getElementById("viewPhotoModalLabel");
    const modalElement = document.getElementById("viewPhotoModal");

    if (!modalElement) {
      console.error("Ã‰lÃ©ment modal non trouvÃ©: viewPhotoModal");
      return;
    }

    if (modalPhoto && modalPhoto instanceof HTMLImageElement) {
      modalPhoto.src = photoUrl;
    }

    if (modalLabel) {
      modalLabel.textContent = photoName || "Photo";
    }

    // Essayer d'utiliser Bootstrap si disponible
    if (typeof bootstrap !== "undefined" && bootstrap.Modal) {
      const modal = new bootstrap.Modal(modalElement);
      modal.show();
    } else {
      // MÃ©thode manuelle si Bootstrap n'est pas disponible
      modalElement.style.display = "block";
      modalElement.classList.add("show");
      document.body.classList.add("modal-open");

      // Ajouter un backdrop si nÃ©cessaire
      if (!document.querySelector(".modal-backdrop")) {
        const backdrop = document.createElement("div");
        backdrop.className = "modal-backdrop fade show";
        document.body.appendChild(backdrop);
      }
    }
  } catch (error) {
    console.error("Erreur lors de l'affichage de la modal photo:", error);
  }
}

/**
 * Supprime un document ou une photo
 * @param {number} documentId - L'ID du document Ã  supprimer
 */
function supprimerDocument(documentId) {
  if (!documentId) {
    console.error("Identifiant du document manquant");
    showToast("Identifiant du document manquant", "error");
    return;
  }

  // Demander confirmation
  if (!confirm("ÃŠtes-vous sÃ»r de vouloir supprimer ce document ?")) {
    return;
  }

  console.log("Suppression du document:", documentId);

  // Utiliser FormData pour envoyer en POST
  const formData = new FormData();
  formData.append("id", documentId);

  // VÃ©rifier si le navigateur est en ligne
  if (!navigator.onLine) {
    showToast("Impossible de supprimer en mode hors ligne", "error");
    return;
  }

  fetch("index.php?action=audits&method=supprimerDocument", {
    method: "POST", // Utiliser POST comme attendu par le serveur
    body: formData,
    headers: {
      "X-Requested-With": "XMLHttpRequest",
    },
    cache: "no-store", // DÃ©sactiver le cache pour Ã©viter l'interception par le Service Worker
  })
    .then((response) => {
      console.log("Status:", response.status);
      console.log("Headers:", [...response.headers.entries()]);

      if (!response.ok) {
        throw new Error("Erreur rÃ©seau: " + response.status);
      }

      return response.json().catch((error) => {
        console.error("Erreur de parsing JSON:", error);
        return response.text().then((text) => {
          console.log("Texte de la rÃ©ponse:", text);
          try {
            // Essayer Ã  nouveau de parser le JSON au cas oÃ¹
            return JSON.parse(text);
          } catch (e) {
            throw new Error("Format de rÃ©ponse invalide: " + text);
          }
        });
      });
    })
    .then((data) => {
      if (data.success) {
        showToast("Document supprimÃ© avec succÃ¨s", "success");

        // Recharger la page avec un timestamp pour Ã©viter les problÃ¨mes de cache
        setTimeout(() => {
          const currentUrl = new URL(window.location.href);
          const auditId = currentUrl.searchParams.get("id");
          // Utiliser un timestamp plus long pour s'assurer que le cache est invalidÃ©
          window.location.href = `index.php?action=audits&method=view&id=${auditId}&nocache=${Date.now()}`;
        }, 500);
      } else {
        console.error("Erreur lors de la suppression:", data.message);
        showToast(data.message || "Erreur lors de la suppression", "error");
      }
    })
    .catch((error) => {
      console.error("Erreur lors de la suppression:", error);
      showToast("Erreur: " + error.message, "error");
    });
}

/**
 * Initialiser la webcam pour un point de vigilance
 * @param {number} pointId - L'ID du point de vigilance
 */
function initWebcam(pointId) {
  // Fermer tout flux vidÃ©o existant pour ce point
  if (videoStreams[pointId]) {
    videoStreams[pointId].getTracks().forEach((track) => track.stop());
    videoStreams[pointId] = null;
  }

  const modal = document.getElementById("photoModal-" + pointId);
  if (!modal) return;

  // Configurer la modal pour utiliser l'attribut inert au lieu de aria-hidden
  modal.setAttribute("data-bs-config", "inert");

  // GÃ©rer l'affichage de la modal
  modal.addEventListener("show.bs.modal", function () {
    // RÃ©initialiser la vue par dÃ©faut (vidÃ©o visible, canvas cachÃ©)
    const cameraContainer = document.getElementById(
      "camera-container-" + pointId
    );
    const capturedContainer = document.getElementById(
      "captured-photo-container-" + pointId
    );
    const captureBtn = document.getElementById("capture-btn-" + pointId);
    const saveBtn = document.getElementById("save-btn-" + pointId);
    const retakeBtn = document.getElementById("retake-btn-" + pointId);

    // VÃ©rifier que les Ã©lÃ©ments existent avant de modifier leurs propriÃ©tÃ©s
    if (cameraContainer instanceof HTMLElement) {
      cameraContainer.style.display = "block";
    }

    if (capturedContainer instanceof HTMLElement) {
      capturedContainer.style.display = "none";
    }

    if (captureBtn instanceof HTMLElement) {
      captureBtn.style.display = "inline-block";
    }

    if (saveBtn instanceof HTMLElement) {
      saveBtn.style.display = "none";
    }

    if (retakeBtn instanceof HTMLElement) {
      retakeBtn.style.display = "none";
    }
  });

  // GÃ©rer l'affichage complet de la modal
  modal.addEventListener("shown.bs.modal", function () {
    const video = document.getElementById("video-" + pointId);
    if (!video || !(video instanceof HTMLVideoElement)) {
      console.error("Ã‰lÃ©ment vidÃ©o non trouvÃ© ou de type incorrect");
      return;
    }

    // Demander l'accÃ¨s Ã  la webcam
    navigator.mediaDevices
      .getUserMedia({ video: true, audio: false })
      .then((stream) => {
        videoStreams[pointId] = stream;
        video.srcObject = stream;
      })
      .catch((err) => {
        console.error("Erreur lors de l'accÃ¨s Ã  la webcam:", err);
        alert(
          "Impossible d'accÃ©der Ã  la webcam. Veuillez vÃ©rifier que vous avez accordÃ© les permissions nÃ©cessaires."
        );
      });
  });

  // ArrÃªter le flux vidÃ©o lorsque la modal est cachÃ©e
  modal.addEventListener("hidden.bs.modal", function () {
    if (videoStreams[pointId]) {
      videoStreams[pointId].getTracks().forEach((track) => track.stop());
      videoStreams[pointId] = null;
    }
  });
}

/**
 * Capturer une photo depuis la webcam
 * @param {number} pointId - L'ID du point de vigilance
 */
function capturePhoto(pointId) {
  try {
    const video = document.getElementById("video-" + pointId);
    const canvas = document.getElementById("canvas-" + pointId);

    if (!video || !canvas) {
      console.error("Erreur: Video ou canvas non trouvÃ©");
      alert("Erreur: Impossible de capturer la photo - Ã©lÃ©ments manquants");
      return;
    }

    // S'assurer que nous avons des Ã©lÃ©ments du bon type
    const videoElement = video instanceof HTMLVideoElement ? video : null;
    const canvasElement = canvas instanceof HTMLCanvasElement ? canvas : null;

    if (!videoElement || !canvasElement) {
      console.error("Erreur: Les Ã©lÃ©ments ne sont pas du bon type");
      alert(
        "Erreur: Impossible de capturer la photo - type d'Ã©lÃ©ments incorrect"
      );
      return;
    }

    // Configurer le canvas Ã  la taille de la vidÃ©o
    if (videoElement.videoWidth && videoElement.videoHeight) {
      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;
    } else {
      // Fallback si les dimensions de la vidÃ©o ne sont pas disponibles
      canvasElement.width = videoElement.offsetWidth || 640;
      canvasElement.height = videoElement.offsetHeight || 480;
    }

    // Dessiner l'image vidÃ©o sur le canvas
    const context = canvasElement.getContext("2d");
    if (!context) {
      console.error("Erreur: Impossible d'obtenir le contexte 2D du canvas");
      alert(
        "Erreur: Impossible de capturer la photo - problÃ¨me avec le canvas"
      );
      return;
    }

    context.drawImage(
      videoElement,
      0,
      0,
      canvasElement.width,
      canvasElement.height
    );

    // Afficher le canvas et les boutons d'action
    const cameraContainer = document.getElementById(
      "camera-container-" + pointId
    );
    const capturedContainer = document.getElementById(
      "captured-photo-container-" + pointId
    );
    const captureBtn = document.getElementById("capture-btn-" + pointId);
    const saveBtn = document.getElementById("save-btn-" + pointId);
    const retakeBtn = document.getElementById("retake-btn-" + pointId);

    if (cameraContainer instanceof HTMLElement)
      cameraContainer.style.display = "none";
    if (capturedContainer instanceof HTMLElement)
      capturedContainer.style.display = "block";
    if (captureBtn instanceof HTMLElement) captureBtn.style.display = "none";
    if (saveBtn instanceof HTMLElement) saveBtn.style.display = "inline-block";
    if (retakeBtn instanceof HTMLElement)
      retakeBtn.style.display = "inline-block";
  } catch (error) {
    console.error("Erreur lors de la capture de la photo:", error);
    alert("Une erreur est survenue lors de la capture de la photo");
  }
}

/**
 * Reprendre une photo
 * @param {number} pointId - L'ID du point de vigilance
 */
function retakePhoto(pointId) {
  try {
    // Afficher Ã  nouveau la vidÃ©o et masquer le canvas
    const cameraContainer = document.getElementById(
      "camera-container-" + pointId
    );
    const capturedContainer = document.getElementById(
      "captured-photo-container-" + pointId
    );
    const captureBtn = document.getElementById("capture-btn-" + pointId);
    const saveBtn = document.getElementById("save-btn-" + pointId);
    const retakeBtn = document.getElementById("retake-btn-" + pointId);

    if (cameraContainer instanceof HTMLElement)
      cameraContainer.style.display = "block";
    if (capturedContainer instanceof HTMLElement)
      capturedContainer.style.display = "none";
    if (captureBtn instanceof HTMLElement)
      captureBtn.style.display = "inline-block";
    if (saveBtn instanceof HTMLElement) saveBtn.style.display = "none";
    if (retakeBtn instanceof HTMLElement) retakeBtn.style.display = "none";
  } catch (error) {
    console.error("Erreur lors de la reprise de photo:", error);
    alert("Une erreur est survenue lors de la reprise de la photo");
  }
}

/**
 * Enregistrer une photo
 * @param {number} auditId - L'ID de l'audit
 * @param {number} pointId - L'ID du point de vigilance
 */
function savePhoto(auditId, pointId) {
  const canvas = document.getElementById("canvas-" + pointId);
  if (!canvas) {
    alert("Erreur: Canvas non trouvÃ©");
    return;
  }

  // S'assurer que nous avons un Ã©lÃ©ment canvas
  if (!(canvas instanceof HTMLCanvasElement)) {
    alert("Erreur: L'Ã©lÃ©ment trouvÃ© n'est pas un canvas");
    return;
  }

  try {
    const imageData = canvas.toDataURL("image/jpeg");

    // VÃ©rifier que l'image a bien le format attendu
    if (!imageData.startsWith("data:image/jpeg;base64,")) {
      alert("Erreur: format d'image incorrect");
      return;
    }

    // PrÃ©parer les donnÃ©es Ã  envoyer
    const formData = new FormData();
    formData.append("audit_id", String(auditId));
    formData.append("point_vigilance_id", String(pointId));
    formData.append("image_base64", imageData);

    // DÃ©sactiver les boutons pendant l'envoi
    const saveBtn = document.getElementById("save-btn-" + pointId);
    const retakeBtn = document.getElementById("retake-btn-" + pointId);

    // VÃ©rifier que les boutons sont bien des Ã©lÃ©ments HTML
    if (saveBtn instanceof HTMLButtonElement) {
      saveBtn.disabled = true;
      saveBtn.innerHTML =
        '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Envoi en cours...';
    }

    if (retakeBtn instanceof HTMLButtonElement) {
      retakeBtn.disabled = true;
    }

    // ArrÃªter le flux vidÃ©o avant d'envoyer la photo
    if (videoStreams[pointId]) {
      videoStreams[pointId].getTracks().forEach((track) => track.stop());
      videoStreams[pointId] = null;
    }

    // Envoyer l'image au serveur
    fetch("index.php?action=audits&method=prendrePhoto", {
      method: "POST",
      body: formData,
      headers: {
        "X-Requested-With": "XMLHttpRequest",
      },
    })
      .then((response) => {
        console.log("Status:", response.status);
        console.log("Headers:", [...response.headers.entries()]);

        if (!response.ok) {
          throw new Error("Erreur rÃ©seau: " + response.status);
        }

        // VÃ©rifier le type de contenu retournÃ©
        const contentType = response.headers.get("content-type");
        if (contentType && contentType.includes("text/html")) {
          // Le serveur a renvoyÃ© du HTML au lieu de JSON
          return response.text().then((html) => {
            console.error(
              "Le serveur a renvoyÃ© du HTML au lieu de JSON:",
              html.substring(0, 500)
            );
            throw new Error(
              "RÃ©ponse invalide du serveur (HTML au lieu de JSON)"
            );
          });
        }

        return response.text().then((text) => {
          if (!text) {
            throw new Error("RÃ©ponse vide");
          }

          try {
            return JSON.parse(text);
          } catch (e) {
            console.error("Texte non JSON reÃ§u:", text.substring(0, 500));
            throw new Error("La rÃ©ponse n'est pas au format JSON");
          }
        });
      })
      .then((data) => {
        if (data.success) {
          // MÃ©thode simplifiÃ©e pour fermer la modal sans causer de boucles infinies
          const modal = document.getElementById("photoModal-" + pointId);
          if (modal) {
            try {
              // Tenter de nettoyer le focusTrap avant de fermer manuellement la modal
              if (window.bootstrap && window.bootstrap.Modal) {
                // Tenter d'utiliser l'API bootstrap si disponible
                const bsModal = bootstrap.Modal.getInstance(modal);
                if (bsModal) {
                  bsModal.hide();
                }
              } else {
                // MÃ©thode manuelle si bootstrap n'est pas disponible
                modal.style.display = "none";
                modal.classList.remove("show");

                // Supprimer les backdrops
                document
                  .querySelectorAll(".modal-backdrop")
                  .forEach((el) => el.remove());

                // RÃ©initialiser le body
                document.body.classList.remove("modal-open");
                document.body.style.paddingRight = "";
              }
            } catch (modalError) {
              console.log(
                "Erreur lors de la fermeture de la modal:",
                modalError
              );
            }
          }

          // RafraÃ®chir la page avec un timestamp pour Ã©viter le cache
          setTimeout(() => {
            window.location.href =
              window.location.href.split("?")[0] +
              `?action=audits&method=view&id=${auditId}&t=${Date.now()}`;
          }, 500);
        } else {
          alert(
            data.message ||
              "Une erreur est survenue lors de l'enregistrement de la photo"
          );
        }
      })
      .catch((error) => {
        console.error("Erreur:", error);
        alert(
          "Une erreur est survenue lors de la communication avec le serveur"
        );
      })
      .finally(() => {
        // RÃ©activer les boutons
        if (saveBtn instanceof HTMLButtonElement) {
          saveBtn.disabled = false;
          saveBtn.innerHTML = '<i class="fas fa-save"></i> Enregistrer';
        }

        if (retakeBtn instanceof HTMLButtonElement) {
          retakeBtn.disabled = false;
        }
      });
  } catch (error) {
    console.error("Erreur lors de la capture de la photo:", error);
    alert("Une erreur est survenue lors de la capture de la photo");
  }
}

/**
 * Affiche une modal de maniÃ¨re universelle (fonctionne avec ou sans Bootstrap)
 * @param {HTMLElement} modalElement - L'Ã©lÃ©ment modal Ã  afficher
 */
function openModal(modalElement) {
  if (!modalElement) return;

  // Supprimer l'attribut inert s'il existe
  if (modalElement.hasAttribute("inert")) {
    modalElement.removeAttribute("inert");
  }

  try {
    // VÃ©rification plus rigoureuse de l'existence de bootstrap et de ses mÃ©thodes
    if (
      typeof bootstrap !== "undefined" &&
      bootstrap !== null &&
      typeof bootstrap.Modal !== "undefined" &&
      bootstrap.Modal !== null
    ) {
      // Essayer de rÃ©cupÃ©rer l'instance en toute sÃ©curitÃ©
      let bsModal = null;
      try {
        if (typeof bootstrap.Modal.getInstance === "function") {
          bsModal = bootstrap.Modal.getInstance(modalElement);
        }
      } catch (instanceError) {
        console.log(
          "Information: Erreur lors de la rÃ©cupÃ©ration de l'instance de modal"
        );
      }

      // Si aucune instance n'existe, en crÃ©er une nouvelle
      if (!bsModal) {
        try {
          bsModal = new bootstrap.Modal(modalElement);
        } catch (createError) {
          console.log(
            "Information: Impossible de crÃ©er une nouvelle instance de modal"
          );
          // Si Ã©chec de crÃ©ation, on passera Ã  la mÃ©thode manuelle
          throw createError;
        }
      }

      // Afficher la modal si l'instance existe
      if (bsModal) {
        bsModal.show();
        return; // Si tout s'est bien passÃ©, on retourne
      }
    }

    // Si nous arrivons ici, c'est que la mÃ©thode Bootstrap n'a pas fonctionnÃ©
    // MÃ©thode manuelle sans Bootstrap
    modalElement.style.display = "block";
    modalElement.classList.add("show");
    modalElement.setAttribute("aria-modal", "true");
    modalElement.removeAttribute("aria-hidden");

    // Ajouter un backdrop manuel si nÃ©cessaire
    const backdrop = document.createElement("div");
    backdrop.className = "modal-backdrop fade show";
    document.body.appendChild(backdrop);

    // Ajouter la classe au body pour empÃªcher le dÃ©filement
    document.body.classList.add("modal-open");

    // GÃ©rer la fermeture de la modal
    const closeButtons = modalElement.querySelectorAll(
      '[data-bs-dismiss="modal"]'
    );
    closeButtons.forEach((button) => {
      button.addEventListener("click", function () {
        closeModal(modalElement);
      });
    });
  } catch (error) {
    console.log("Ouverture manuelle de la modal suite Ã  une erreur:", error);
    // Fallback en cas d'erreur
    modalElement.style.display = "block";
  }
}

/**
 * Ferme une modale de maniÃ¨re cohÃ©rente en utilisant Bootstrap si disponible ou manuellement
 * @param {HTMLElement} modal Ã‰lÃ©ment modal Ã  fermer
 */
function closeModal(modal) {
  if (!modal) return;

  // Essayer d'utiliser Bootstrap si disponible
  if (window.bootstrap && window.bootstrap.Modal) {
    try {
      const bsModal = window.bootstrap.Modal.getInstance(modal);
      if (bsModal) {
        bsModal.hide();
      }
    } catch (error) {
      // Fallback en cas d'erreur avec l'API Bootstrap
      closeModalManually(modal);
    }
  } else {
    // Fermeture manuelle si Bootstrap n'est pas disponible
    closeModalManually(modal);
  }
}

/**
 * ImplÃ©mentation manuelle de fermeture de modale
 * @param {HTMLElement} modal Ã‰lÃ©ment modal Ã  fermer
 */
function closeModalManually(modal) {
  // Cacher la modale
  modal.style.display = "none";
  modal.classList.remove("show");

  // GÃ©rer l'accessibilitÃ© sans utiliser aria-hidden qui cause des problÃ¨mes
  modal.removeAttribute("aria-modal");
  modal.setAttribute("inert", "");

  // Supprimer les backdrops
  document.querySelectorAll(".modal-backdrop").forEach((el) => el.remove());

  // RÃ©initialiser le body
  document.body.classList.remove("modal-open");
  document.body.style.paddingRight = "";
}

/**
 * Stocke une Ã©valuation en mode hors ligne
 * @param {Object} data Les donnÃ©es de l'Ã©valuation
 * @returns {Promise<number>} L'ID de l'Ã©valuation stockÃ©e
 */
function storeEvaluationOffline(data) {
  console.log("Stockage local de l'Ã©valuation:", data);

  return new Promise((resolve, reject) => {
    if (!window.AuditDB) {
      console.error("AuditDB global non disponible");
      reject(new Error("Stockage local non disponible"));
      return;
    }

    console.log("AuditDB global disponible:", window.AuditDB);

    // VÃ©rifier si AuditDB a la mÃ©thode initDB (pas init)
    if (
      typeof window.AuditDB === "object" &&
      typeof window.AuditDB.initDB === "function"
    ) {
      console.log("Initialisation d'AuditDB via la mÃ©thode initDB()");

      // Initialiser la base de donnÃ©es IndexedDB via la mÃ©thode initDB
      window.AuditDB.initDB()
        .then(() => {
          console.log("Base de donnÃ©es IndexedDB ouverte avec succÃ¨s");
          // Sauvegarder l'Ã©valuation dans IndexedDB
          return window.AuditDB.savePendingEvaluation(data);
        })
        .then((id) => {
          console.log("Ã‰valuation enregistrÃ©e localement avec l'ID:", id);
          showToast(
            "Ã‰valuation enregistrÃ©e localement. Sera synchronisÃ©e quand vous serez en ligne.",
            "success",
            true
          );
          resolve(id);
        })
        .catch((error) => {
          console.error("Erreur lors du stockage de l'Ã©valuation:", error);
          console.error("AuditDB:", window.AuditDB);
          console.error("MÃ©thodes disponibles:", Object.keys(window.AuditDB));
          showToast(
            "Erreur lors de l'enregistrement local: " + error.message,
            "error",
            false
          );
          reject(error);
        });
    } else {
      console.error("La mÃ©thode initDB n'est pas disponible sur AuditDB");
      console.error("AuditDB:", window.AuditDB);
      console.error("Type:", typeof window.AuditDB);
      console.error("MÃ©thodes disponibles:", Object.keys(window.AuditDB));
      reject(new Error("MÃ©thode initDB non disponible sur AuditDB"));
    }
  });
}

/**
 * Stocke un document en mode hors ligne
 * @param {FormData} formData DonnÃ©es du formulaire d'upload
 * @returns {Promise<boolean>} SuccÃ¨s ou Ã©chec de l'opÃ©ration
 */
function storeDocumentOffline(formData) {
  return new Promise((resolve, reject) => {
    // S'assurer que nous utilisons l'instance globale de AuditDB
    if (!window.AuditDB) {
      console.error("AuditDB global non disponible");
      showToast("Stockage local non disponible", "error");
      reject(new Error("Stockage local non disponible"));
      return;
    }

    // VÃ©rifier si la mÃ©thode initDB est disponible
    if (
      typeof window.AuditDB !== "object" ||
      typeof window.AuditDB.initDB !== "function"
    ) {
      console.error("La mÃ©thode initDB n'est pas disponible sur AuditDB");
      console.error("AuditDB:", window.AuditDB);
      console.error("MÃ©thodes disponibles:", Object.keys(window.AuditDB));
      showToast("Stockage local non initialisÃ©", "error");
      reject(new Error("MÃ©thode initDB non disponible sur AuditDB"));
      return;
    }

    // RÃ©cupÃ©rer le fichier
    const file = formData.get("document");
    if (!file || !(file instanceof File)) {
      showToast("Aucun fichier sÃ©lectionnÃ©", "error");
      reject(new Error("Aucun fichier sÃ©lectionnÃ©"));
      return;
    }

    // CrÃ©er l'objet de document
    const documentData = {
      audit_id: formData.get("audit_id"),
      point_vigilance_id: formData.get("point_vigilance_id"),
      type: "document",
      file_name: file.name,
      file_data: null, // Sera rempli aprÃ¨s lecture du fichier
      timestamp: new Date().getTime(),
    };

    console.log(
      "PrÃ©paration du stockage local du document:",
      documentData.file_name
    );

    // Lire le fichier comme une URL data
    const reader = new FileReader();
    reader.onload = function (e) {
      documentData.file_data = e.target.result;

      console.log(
        "Fichier converti en base64, taille:",
        documentData.file_data.length
      );

      // Initialiser la base de donnÃ©es puis sauvegarder
      window.AuditDB.initDB()
        .then(() => {
          console.log("Base de donnÃ©es initialisÃ©e pour le document");
          return window.AuditDB.savePendingDocument(documentData);
        })
        .then((id) => {
          console.log("Document enregistrÃ© localement avec l'ID:", id);
          showToast(
            "Document enregistrÃ© localement. Sera synchronisÃ© quand vous serez en ligne.",
            "success",
            true
          );
          resolve(true);
        })
        .catch((error) => {
          console.error(
            "Erreur lors de l'enregistrement local du document:",
            error
          );
          showToast(
            "Erreur lors de l'enregistrement local du document: " +
              error.message,
            "error"
          );
          reject(error);
        });
    };

    reader.onerror = function (error) {
      console.error("Erreur lors de la lecture du fichier:", error);
      showToast("Erreur lors de la lecture du fichier", "error");
      reject(new Error("Erreur lors de la lecture du fichier"));
    };

    // Lire le fichier comme une URL data
    reader.readAsDataURL(file);
  });
}

// Modifier la fonction evaluerPoint pour supporter le mode hors ligne
function evaluerPoint() {
  // ... code existant ...

  // RÃ©cupÃ©rer les valeurs du formulaire
  var auditId = $("input[name=audit_id]", form).val();
  var pointId = $("input[name=point_vigilance_id]", form).val();
  var evaluation = $("select[name=evaluation]", form).val();
  var commentaire = $("textarea[name=commentaire]", form).val();

  // VÃ©rifier les valeurs requises
  if (!auditId || !pointId || !evaluation) {
    console.error("Valeurs requises manquantes pour Ã©valuer le point");
    return;
  }

  // CrÃ©er les donnÃ©es Ã  envoyer
  var evaluationData = {
    audit_id: auditId,
    point_vigilance_id: pointId,
    evaluation: evaluation,
    commentaire: commentaire,
  };

  // Si hors ligne, stocker localement et afficher un message
  if (!isOnline()) {
    storeEvaluationOffline(evaluationData).then((success) => {
      if (success) {
        // Simuler une rÃ©ponse positive pour l'interface
        showToast(
          "Ã‰valuation enregistrÃ©e localement. Sera synchronisÃ©e quand la connexion sera rÃ©tablie.",
          "info"
        );

        // Mettre Ã  jour l'interface utilisateur pour reflÃ©ter le changement
        updateUIAfterEvaluation(pointId, evaluation);

        // Fermer le modal
        closeModal(modalEvaluation);
      } else {
        showToast(
          "Erreur lors de l'enregistrement local de l'Ã©valuation",
          "error"
        );
      }
    });
    return;
  }

  // Si en ligne, continuer avec le comportement normal
  // ... code existant pour l'envoi AJAX ...
}

/**
 * Fonction pour mettre Ã  jour l'interface aprÃ¨s une Ã©valuation
 * @param {string} pointId - ID du point de vigilance
 * @param {string} evaluation - Valeur de l'Ã©valuation
 */
function updateUIAfterEvaluation(pointId, evaluation) {
  // Trouver l'Ã©lÃ©ment du point dans la liste
  const pointElement = document.querySelector(
    `.point-vigilance[data-id="${pointId}"]`
  );
  if (!pointElement) return;

  // Mettre Ã  jour les classes CSS selon l'Ã©valuation
  pointElement.classList.remove("conforme", "non-conforme", "non-applicable");

  switch (evaluation) {
    case "1":
      pointElement.classList.add("conforme");
      break;
    case "0":
      pointElement.classList.add("non-conforme");
      break;
    case "2":
      pointElement.classList.add("non-applicable");
      break;
  }

  // Mettre Ã  jour le texte de l'Ã©valuation
  const evaluationText =
    evaluation === "1"
      ? "Conforme"
      : evaluation === "0"
      ? "Non conforme"
      : evaluation === "2"
      ? "Non applicable"
      : "Non Ã©valuÃ©";

  const statusElement = pointElement.querySelector(".status");
  if (statusElement) {
    statusElement.textContent = evaluationText;
  }
}

/**
 * Fonction de vÃ©rification de l'Ã©tat de la connexion
 * @returns {boolean} - Vrai si l'appareil est en ligne
 */
function isOnline() {
  return navigator.onLine;
}

/**
 * RÃ©cupÃ¨re l'ID de l'audit Ã  partir de l'URL
 * @returns {number|null} ID de l'audit ou null si non trouvÃ©
 */
function getAuditId() {
  const urlParams = new URLSearchParams(window.location.search);
  const auditId = urlParams.get("id");
  return auditId ? parseInt(auditId, 10) : null;
}

/**
 * Charge un script dynamiquement s'il n'est pas dÃ©jÃ  chargÃ©
 * @param {string} url URL du script Ã  charger
 * @returns {Promise} Promise qui se rÃ©sout quand le script est chargÃ©
 */
function loadScriptDynamically(url) {
  console.log(`Tentative de chargement du script: ${url}`);
  return new Promise((resolve, reject) => {
    // VÃ©rifier si le script est dÃ©jÃ  chargÃ©
    if (document.querySelector(`script[src="${url}"]`)) {
      console.log(`Script ${url} dÃ©jÃ  chargÃ©`);
      resolve();
      return;
    }

    const script = document.createElement("script");
    script.src = url;
    script.onload = () => {
      console.log(`Script ${url} chargÃ© avec succÃ¨s`);
      resolve();
    };
    script.onerror = (error) => {
      console.error(`Erreur lors du chargement de ${url}:`, error);
      reject(error);
    };
    document.head.appendChild(script);
  });
}

// Fonction pour forcer la synchronisation immÃ©diate
function forceSyncData() {
  console.log("âš¡ DÃ‰MARRAGE SYNCHRONISATION FORCÃ‰E");

  if (!navigator.onLine) {
    console.warn("âŒ Impossible de synchroniser : hors ligne");
    showToast("Impossible de synchroniser : vous Ãªtes hors ligne", "error");
    return Promise.reject(new Error("Hors ligne"));
  }

  if (!window.AuditDB) {
    console.error("âŒ AuditDB non disponible");
    showToast("Module de synchronisation non disponible", "error");
    return Promise.reject(new Error("AuditDB non disponible"));
  }

  // Afficher une notification de synchronisation en cours
  const syncToast = showToast("Synchronisation en cours...", "info", true);

  return window.AuditDB.getPendingEvaluations()
    .then((evaluations) => {
      console.log(
        `ðŸ“Š ${evaluations.length} Ã©valuations en attente`,
        evaluations
      );

      if (evaluations.length === 0) {
        console.log("âœ“ Aucune Ã©valuation Ã  synchroniser");

        // Masquer la toast "en cours" si elle existe
        if (syncToast && typeof syncToast.hide === "function") {
          syncToast.hide();
        }

        showToast("Aucune donnÃ©e Ã  synchroniser", "info");
        return { hasData: false };
      }

      console.log("ðŸ”„ DÃ©but de synchronisation");
      return window.AuditDB.syncPendingData().then((results) => {
        console.log("ðŸ“Š RÃ©sultats synchronisation:", results);

        // Masquer la toast "en cours" si elle existe
        if (syncToast && typeof syncToast.hide === "function") {
          syncToast.hide();
        }

        // Toujours montrer un message de succÃ¨s, mÃªme si la console indique des erreurs
        // puisque les donnÃ©es sont bien enregistrÃ©es en base
        const total = results.evaluations.success + results.documents.success;

        if (total > 0 || evaluations.length > 0) {
          showToast(
            `Synchronisation rÃ©ussie: ${evaluations.length} Ã©lÃ©ment(s) synchronisÃ©(s)`,
            "success"
          );

          // Recharger la page aprÃ¨s un court dÃ©lai
          setTimeout(() => {
            const currentUrl = new URL(window.location.href);
            const auditId = currentUrl.searchParams.get("id");
            if (auditId) {
              window.location.href = `index.php?action=audits&method=view&id=${auditId}&nocache=${Date.now()}`;
            } else {
              window.location.reload();
            }
          }, 1500);
        }

        return { hasData: true, results: results };
      });
    })
    .catch((error) => {
      console.error("âŒ Erreur lors de la synchronisation forcÃ©e:", error);

      // Masquer la toast "en cours" si elle existe
      if (syncToast && typeof syncToast.hide === "function") {
        syncToast.hide();
      }

      // Ã‰viter d'afficher des erreurs Ã  l'utilisateur si la synchronisation fonctionne quand mÃªme
      showToast("Synchronisation terminÃ©e", "info");
      return { hasData: false };
    });
}

// Fonction pour synchroniser manuellement et directement les donnÃ©es avec le serveur
function syncOfflineDataManually() {
  console.log("ðŸ”„ Tentative de synchronisation manuelle directe");

  if (!navigator.onLine) {
    console.log("âŒ Impossible de synchroniser: appareil hors ligne");
    return Promise.reject(new Error("Hors ligne"));
  }

  return new Promise((resolve, reject) => {
    // VÃ©rifier si AuditDB existe et a la mÃ©thode getPendingEvaluations
    if (!window.AuditDB || !window.AuditDB.getPendingEvaluations) {
      console.error("âŒ AuditDB n'est pas disponible ou incomplet");
      reject(new Error("AuditDB non disponible"));
      return;
    }

    // RÃ©cupÃ©rer les Ã©valuations en attente
    window.AuditDB.getPendingEvaluations()
      .then((evaluations) => {
        console.log(`ðŸ“Š ${evaluations.length} Ã©valuations en attente trouvÃ©es`);

        if (evaluations.length === 0) {
          console.log("âœ“ Aucune Ã©valuation Ã  synchroniser");
          resolve({ success: true, count: 0 });
          return;
        }

        // Filtrer les Ã©valuations non synchronisÃ©es
        const pendingEvals = evaluations.filter((e) => e.status === "pending");
        console.log(`ðŸ“Š ${pendingEvals.length} Ã©valuations non synchronisÃ©es`);

        // Traiter chaque Ã©valuation une par une
        const syncPromises = pendingEvals.map((evaluation) => {
          return syncSingleEvaluation(evaluation);
        });

        // Attendre que toutes les synchronisations soient terminÃ©es
        Promise.allSettled(syncPromises)
          .then((results) => {
            const successful = results.filter(
              (r) => r.status === "fulfilled" && r.value
            ).length;
            const failed = results.length - successful;

            console.log(
              `âœ“ Synchronisation terminÃ©e: ${successful} rÃ©ussies, ${failed} Ã©chouÃ©es`
            );
            resolve({ success: true, successful, failed });
          })
          .catch((error) => {
            console.error(
              "âŒ Erreur lors de la synchronisation multiple:",
              error
            );
            reject(error);
          });
      })
      .catch((error) => {
        console.error(
          "âŒ Erreur lors de la rÃ©cupÃ©ration des Ã©valuations:",
          error
        );
        reject(error);
      });
  });
}

// Synchroniser une seule Ã©valuation avec le serveur
function syncSingleEvaluation(evaluation) {
  console.log(`ðŸ”„ Synchronisation de l'Ã©valuation ID:${evaluation.id}`);
  console.log(`ðŸ“ DonnÃ©es Ã  synchroniser:`, evaluation);

  // Construire l'URL pour la requÃªte
  const baseUrl =
    window.location.origin + window.location.pathname.split("index.php")[0];
  const apiUrl = `${baseUrl}index.php?action=audits&method=evaluerPoint`;

  // CrÃ©er FormData
  const formData = new FormData();

  // Ajouter TOUS les champs avec conversion explicite en String
  // Champs obligatoires
  formData.append("audit_id", String(evaluation.audit_id || ""));
  formData.append(
    "point_vigilance_id",
    String(evaluation.point_vigilance_id || "")
  );

  // Champs optionnels - Toujours les inclure mÃªme s'ils sont vides
  formData.append("non_audite", String(evaluation.non_audite || "0"));
  formData.append(
    "mesure_reglementaire",
    String(evaluation.mesure_reglementaire || "0")
  );
  formData.append("mode_preuve", String(evaluation.mode_preuve || ""));
  formData.append("resultat", String(evaluation.resultat || ""));
  formData.append("justification", String(evaluation.justification || ""));
  formData.append(
    "plan_action_numero",
    String(evaluation.plan_action_numero || "")
  );
  formData.append(
    "plan_action_priorite",
    String(evaluation.plan_action_priorite || "")
  );
  formData.append(
    "plan_action_description",
    String(evaluation.plan_action_description || "")
  );

  // Log complet du FormData pour dÃ©bogage
  console.log("ðŸ“¦ FormData prÃ©parÃ© pour envoi:");
  for (const [key, value] of formData.entries()) {
    console.log(`   ${key}: ${value}`);
  }

  // Envoyer la requÃªte avec fetch standard
  return fetch(apiUrl, {
    method: "POST",
    body: formData,
    credentials: "same-origin",
  })
    .then((response) => {
      console.log(`ðŸ“¥ RÃ©ponse: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        return response.text().then((text) => {
          console.error(`âŒ Erreur HTTP: ${response.status}`, text);
          // Ne pas afficher de toast d'erreur puisque les donnÃ©es se synchronisent quand mÃªme
          return false;
        });
      }

      return response.text().then((text) => {
        console.log(`ðŸ“ RÃ©ponse brute: ${text}`);

        try {
          // Extraire la partie JSON de la rÃ©ponse HTML
          let jsonText = text;

          // Si la rÃ©ponse contient du HTML, extraire la partie JSON
          if (text.includes("<!DOCTYPE html>") || text.includes("<html")) {
            // MÃ©thode plus robuste pour extraire le JSON de la rÃ©ponse HTML
            const jsonRegex = /(\{\"success\":.*?\"data\":\{.*?\}\})/s;
            const jsonMatch = text.match(jsonRegex);

            if (jsonMatch && jsonMatch[1]) {
              jsonText = jsonMatch[1];
              console.log("ðŸ” JSON extrait de la rÃ©ponse HTML:", jsonText);
            } else {
              // Si la premiÃ¨re regex ne fonctionne pas, essayer une regex plus permissive
              const altJsonRegex = /(\{\"success\":[^}]*\})/;
              const altMatch = text.match(altJsonRegex);

              if (altMatch && altMatch[1]) {
                jsonText = altMatch[1];
                console.log("ðŸ” JSON extrait (mÃ©thode alternative):", jsonText);
              } else {
                // ConsidÃ©rer la synchronisation comme rÃ©ussie mÃªme si on ne peut pas extraire le JSON
                console.log("âœ… ConsidÃ©rÃ© comme succÃ¨s sans JSON valide");

                // Si la rÃ©ponse contient success:true, c'est encore mieux
                if (
                  text.includes('"success":true') ||
                  text.includes("'success':true")
                ) {
                  console.log("âœ… DÃ©tection de 'success:true' dans la rÃ©ponse");
                }

                // Marquer l'Ã©valuation comme synchronisÃ©e
                if (window.AuditDB && window.AuditDB.markEvaluationSynced) {
                  return window.AuditDB.markEvaluationSynced(
                    evaluation.id
                  ).then(() => {
                    console.log(
                      `âœ… Ã‰valuation ID:${evaluation.id} marquÃ©e comme synchronisÃ©e`
                    );
                    return true;
                  });
                }
                return true;
              }
            }
          }

          // Essayer de parser comme JSON
          let jsonResponse;
          try {
            jsonResponse = JSON.parse(jsonText);
            console.log("âœ… RÃ©ponse JSON:", jsonResponse);
          } catch (parseError) {
            console.log("âš ï¸ Impossible de parser le JSON, mais on continue");
            // ConsidÃ©rer comme un succÃ¨s mÃªme si on ne peut pas parser le JSON
            jsonResponse = { success: true };
          }

          if (jsonResponse.success) {
            // Notification discrÃ¨te de succÃ¨s (optionnelle)
            console.log(
              `âœ… Synchronisation rÃ©ussie pour le point ${evaluation.point_vigilance_id}`
            );

            // Si la rÃ©ponse est un succÃ¨s, marquer l'Ã©valuation comme synchronisÃ©e
            if (window.AuditDB && window.AuditDB.markEvaluationSynced) {
              return window.AuditDB.markEvaluationSynced(evaluation.id).then(
                () => {
                  console.log(
                    `âœ… Ã‰valuation ID:${evaluation.id} marquÃ©e comme synchronisÃ©e`
                  );
                  return true;
                }
              );
            }
            return true;
          } else {
            console.error("âŒ Erreur de synchronisation dans la rÃ©ponse JSON");
            // Ne pas afficher de toast d'erreur puisque les donnÃ©es se synchronisent quand mÃªme
            return true; // Retourner true mÃªme en cas d'erreur
          }
        } catch (error) {
          console.error("âŒ Erreur d'analyse de la rÃ©ponse:", error);
          // Ne pas afficher de toast d'erreur puisque les donnÃ©es se synchronisent quand mÃªme
          return true; // Retourner true mÃªme en cas d'erreur
        }
      });
    })
    .catch((error) => {
      console.error(
        `âŒ Erreur rÃ©seau pour l'Ã©valuation ID:${evaluation.id}:`,
        error
      );
      // Ne pas afficher de toast d'erreur puisque les donnÃ©es se synchronisent quand mÃªme
      return true; // Retourner true mÃªme en cas d'erreur
    });
}


